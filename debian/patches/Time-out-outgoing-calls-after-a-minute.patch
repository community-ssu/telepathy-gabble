From 935679ec9ffec0a83e71e9460f76a7afa6a26300 Mon Sep 17 00:00:00 2001
From: Will Thompson <will.thompson@collabora.co.uk>
Date: Thu, 20 Aug 2009 16:26:16 +0100
Subject: [PATCH] Time out outgoing calls after a minute.

This partially reverts commit 424d49860e3c4ed92783e5d6599b4b67cf618cbb,
leaving out the code to time out incoming calls.
---
 src/jingle-session.c |   33 +++++++++++++++++++++++++++++++++
 1 files changed, 33 insertions(+), 0 deletions(-)

diff --git a/src/jingle-session.c b/src/jingle-session.c
index 54959fc..4d5a3fe 100644
--- a/src/jingle-session.c
+++ b/src/jingle-session.c
@@ -96,9 +96,13 @@ struct _GabbleJingleSessionPrivate
   gboolean remote_hold;
   gboolean remote_ringing;
 
+  guint timer_id;
+
   gboolean dispose_has_run;
 };
 
+static guint session_timeout_time = 60000;
+
 typedef struct {
   JingleState state;
   JingleAction *actions;
@@ -185,6 +189,7 @@ gabble_jingle_session_init (GabbleJingleSession *obj)
   priv->state = JS_STATE_PENDING_CREATED;
   priv->locally_accepted = FALSE;
   priv->locally_terminated = FALSE;
+  priv->timer_id = 0;
   priv->dispose_has_run = FALSE;
 }
 
@@ -204,6 +209,7 @@ gabble_jingle_session_dispose (GObject *object)
 
   g_assert ((priv->state == JS_STATE_PENDING_CREATED) ||
       (priv->state == JS_STATE_ENDED));
+  g_assert (priv->timer_id == 0);
 
   g_hash_table_destroy (priv->initiator_contents);
   priv->initiator_contents = NULL;
@@ -1783,6 +1789,19 @@ _on_accept_reply (GObject *sess_as_obj,
     }
 }
 
+static gboolean
+timeout_session (gpointer data)
+{
+  GabbleJingleSession *session = data;
+
+  DEBUG ("session timed out");
+  session->priv->timer_id = 0;
+
+  gabble_jingle_session_terminate (session,
+      TP_CHANNEL_GROUP_CHANGE_REASON_NO_ANSWER, NULL, NULL);
+  return FALSE;
+}
+
 static void
 try_session_initiate_or_accept (GabbleJingleSession *sess)
 {
@@ -1910,6 +1929,20 @@ set_state (GabbleJingleSession *sess,
       state < JS_STATE_ENDED)
     gabble_jingle_session_send_held (sess);
 
+  /* if we just initiated the session, set the session timer */
+  if (priv->local_initiator && (state == JS_STATE_PENDING_INITIATE_SENT))
+    {
+      g_assert (priv->timer_id == 0);
+      priv->timer_id = g_timeout_add (session_timeout_time,
+        timeout_session, sess);
+    }
+  /* if we're active or ended, we can clear the timer */
+  else if ((state >= JS_STATE_ACTIVE) && (priv->timer_id != 0))
+    {
+      g_source_remove (priv->timer_id);
+      priv->timer_id = 0;
+    }
+
   if (state == JS_STATE_ENDED)
     g_signal_emit (sess, signals[TERMINATED], 0, priv->locally_terminated,
         termination_reason);
-- 
1.6.3.3

